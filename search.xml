<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CrushFTP CVE-2025-54309 Analysis</title>
      <link href="/2025/10/09/crushftp-cve-2025-54309-analysis/"/>
      <url>/2025/10/09/crushftp-cve-2025-54309-analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2025-54309-竞争条件bypass漏洞"><a href="#CVE-2025-54309-竞争条件bypass漏洞" class="headerlink" title="CVE-2025-54309 竞争条件bypass漏洞"></a>CVE-2025-54309 竞争条件bypass漏洞</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>CrushFTP是一款跨平台<a href="https://cn-sec.com/archives/tag/%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93">文件传输</a>服务器，支持FTP、SFTP、HTTP&#x2F;S和WebDAV协议，专为安全灵活的数据共享而设计。该软件提供基于Web的管理界面、基于角色的权限控制、目录服务集成以及双因素认证等强大的安全功能，是复杂企业<a href="https://cn-sec.com/archives/tag/%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93">文件传输</a>解决方案的可扩展替代方案。CrushFTP广泛应用于个人用户、小型企业以及大型企业环境中，在全球拥有超过30,000个在线实例。</p></blockquote><p>近日，安全研究人员公开披露了CrushFTP中存在的认证绕过漏洞（CVE-2025-54309）。该漏洞源于CrushFTP在处理AS2信息头时存在竞争条件缺陷，攻击者可以通过精心构造的HTTPS请求序列绕过认证机制。成功利用此漏洞的攻击者可以获得CrushFTP管理员访问权限，进而能够调用内部API接口添加系统管理员账户，执行任意系统命令，造成远程命令执行，同时还可以检索敏感文件、创建恶意文件、修改系统配置等操作。此漏洞已在野外被积极利用，这意味着攻击者获得了文件传输系统的”完全控制权”。</p><p>漏洞的POC已在GitHub上发布。</p><p><strong>漏洞影响范围：</strong></p><p>CrushFTP 10版本：10.8.5前的所有版本。</p><p>CrushFTP 11版本：11.3.4_23前的所有版本。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>CrushFTP各版本docker环境下载地址：</p><p><a href="https://hub.docker.com/r/crushftp/crushftp11/tags?name=11.3.4_22">crushftp&#x2F;crushftp11 Tags | Docker Hub</a></p><p>里面的docker镜像带有“-dev”字样的是带有bash的环境，可通过docker exec -it 进入容器内部。</p><p>一些命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">9090</span>:<span class="number">9090</span> -p <span class="number">8443</span>:<span class="number">443</span> crushftp/crushftp11:<span class="number">11.3</span><span class="number">.3_18</span></span><br><span class="line"></span><br><span class="line">将docker容器中的文件拷贝出来：</span><br><span class="line">● 导出容器为tar文件 docker export <span class="number">5f</span> &gt; container5f.tar </span><br><span class="line">●  复制容器根目录到宿主机目录下 docker cp <span class="number">5f</span>:/ ./container5f</span><br><span class="line"></span><br><span class="line">**调试： 关键是-e进行传参，给镜像中的entrypoint.sh</span><br><span class="line">docker run -it --rm \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">5005</span>:<span class="number">5005</span> \</span><br><span class="line">-e JAVA_TOOL_OPTIONS=<span class="string">&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005&quot;</span> \</span><br><span class="line">-e CRUSHFTP_ADMIN_USERNAME=myadmin \</span><br><span class="line">-e CRUSHFTP_ADMIN_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">crushftp/crushftp11:<span class="number">11.3</span><span class="number">.3_18</span>-dev**</span><br></pre></td></tr></table></figure><p>奇怪的是，目前测试下来（2025.9.3），该漏洞能够成功复现的最新docker环境为crushftp&#x2F;crushftp11:11.3.3_18，而不是cve通报的11.3.4_22，原因暂不得知。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="请求处理流程梳理"><a href="#请求处理流程梳理" class="headerlink" title="请求处理流程梳理"></a>请求处理流程梳理</h3><p>首先简单梳理一下CrushFTP的请求处理逻辑，从接受请求到处理具体命令的部分代码过程。</p><p>服务器端在crushftp.server.ServerSessionHTTP#run方法中，通过while循环，反复处理同一socket的请求，并从请求的cookie中<strong>读取会话信息。</strong></p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image.png"></p><p>随后，经过一系列对请求的初始化处理，调用crushftp.server.ServerSessionHTTP#handle_http_requests方法处理请求：</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image1.png" alt="image.png"></p><p>在该方法中，用了很多 if 来筛选通用POST请求，随后进行一系列登录认证检查，最后通过crushftp.server.ServerSessionAJAX#buildPostItem方法来构建POST请求条目（画重点）</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image2.png" alt="image.png"></p><p>随后又经过了一堆进不去的 if 判断，来到这里。先检查了是否允许匿名用户登录，该方法对于未登录用户的请求，会直接清除掉其user_name字段，使得后面的判断失败。</p><p>随后检查是否能直接跳过登录，直接访问目标；否则检查当前会话中是否已有有效的登录状态”user_logged_in“和”user_name“。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image3.png" alt="image.png"></p><p>检查通过后，会根据请求头的情况执行不同的代码，最主要的漏洞利用位置在下面这里，通过crushftp.server.ServerSessionAJAX#processItems 方法来处理请求中的不同命令。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image4.png" alt="image.png"></p><p>那么关键就是要找到使得user_logged_in字段变成true，同时user_name不为空的地方。</p><p>总结一下请求处理中的几个重要流程：</p><p>接收请求、</p><p>设置会话、</p><p>处理请求：</p><p>{请求头认证、post请求体构建、匿名访问认证、登录状态检查、处理具体命令}</p><h3 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>那么现在回归漏洞点，既然是竞争条件漏洞，而且是认证绕过，那么最先想到的应该是这之间某个位置出现了临时的**已登录状态。**同时在这个窗口当中，这个登陆状态的信息被不同线程共享，导致其他线程以登录状态通过了最后的检查，从而执行了命令。</p><p>回头审计代码的过程中发现，问题出在了crushftp.server.ServerSessionAJAX#buildPostItem方法当中，这个方法用来将请求中的各字段信息保存到crushftp.server.ServerSessionHTTP#thisSession.user_info字段中去，而这里的thisSession实际上是一个crushftp.handlers.SessionCrush类，用于管理会话的各类认证信息。</p><p>但是，在存进去之前，在下图的位置，该方法会调用一次crushftp.handlers.SessionCrush#login_user_pass(boolean, boolean, java.lang.String, java.lang.String)方法，并且前两个参数都设置为了true。并在之后立刻又将crushftp.handlers.SessionCrush#user_info中的”user_logged_in“字段设置为了false。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image5.png" alt="image.png"></p><p>在调试到这里的时候发现，user_logged_in 这个字段的值在login_user_pass方法之后确实变成了true。</p><p>login_user_pass方法具体内容就不写了，总之这是认证中的很关键的一步，用来判断登录状态的，而这里只是构建post请求体的方法，不涉及认证，调用的它的原因是为了<strong>借助登录流程做一些事情</strong>，比如加载用户配置、AS2 partner 配置、设置 home 目录、临时目录，可能还会触发 AS2 签名&#x2F;证书的预加载。然后手动把状态重置，让后续逻辑可以继续验证。</p><p>根据字段名称和这里的处理操作，猜测很有可能就是这里的短暂窗口导致了竞争条件漏洞。那么这个thisSession又是怎么来的呢，这得回到之前提到的流程中的”设置会话“这一步：</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image6.png" alt="image.png"></p><p>不同的请求中，thisSession会从SharedSssion这个类中的根据cookie中的CrushAuth字段来寻找相同的会话，没找到才会新建一个。</p><p>那么到这就说得通了，实际上就是：</p><p><strong>前一个请求在buildPostItem方法中调用了login_user_pass方法，将当前会话Session设置为了已登录状态，而在将已登录状态取消之前，新的请求在这里获取了这个已登录状态的会话，并以登录后的身份成功执行了命令。</strong></p><p>需要注意的是，<strong>buildPostItem</strong> 方法中只有请求中有as2-to字段才会进入这段登录后又取消的逻辑。所以用于竞争的两个请求需要一个存在这个字段且设置为管理员账户，一个不存在。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image7.png" alt="image.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>漏洞利用脚本来自GitHub上公布的<a href="https://github.com/watchtowrlabs/watchTowr-vs-CrushFTP-Authentication-Bypass-CVE-2025-54309">POC</a>，这里我用poc跑了CrushFTP11的近几个版本，不知道为什么，只有11.3.3_18以及之前的版本能够成功复现，对比了一下这之间的代码也没什么区别。待之后再分析了。</p><p>以下是11.3.3_18版本复现情况，成功执行了GetUserList命令，获取了用户信息。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image8.png" alt="image.png"></p><h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><p>针对该漏洞的修复措施在11.3.4_23版本中，之前是直接拿当前的Session来临时登录，再取消；现在是直接新创建了各临时Session来临时登录，还对用户名做了一定的检查（虽然不太清楚这里是干嘛用的）。这样的话就直接杜绝了临时登录的利用窗口。</p><p><img src="/2025/10/09/crushftp-cve-2025-54309-analysis/image9.png" alt="image.png"></p><p>参考：</p><p><a href="https://labs.watchtowr.com/the-one-where-we-just-steal-the-vulnerabilities-crushftp-cve-2025-54309/">The One Where We Just Steal The Vulnerabilities (CrushFTP CVE-2025-54309)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CrushFTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/10/09/hello-world/"/>
      <url>/2025/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
